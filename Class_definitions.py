import hashlib
import random

# The Network class takes care of passing messages between nodes and is in charge of connecting different nodes
class Network:
    def __init__(self,*users):
        if all(map(lambda x: isinstance(x,User), users)):
            self.users = list(users)
        else:
            raise Exception("Invalid input: Network only admits a service")
        self.miners = []
        self.rankers = []
        for user in users:
            if isinstance(x,Miner):
                self.miners.append(user)
            if isinstance(x,Ranker):
                self.rankers.append(user)

    #add users to the network
    def add_users(self,user_lst):
        if all(map(lambda x: isinstance(x,User),user_lst)):
            for user in user_lst:
                self.users.append(user)
                if isinstance(x, Miner):
                    self.miners.append(user)
                if isinstance(x, Ranker):
                    self.rankers.append(user)

    #sends a rating to all the miners in the network
    def send_rating(self,user,rating):
        for miner in self.miners:
            if not(miner is user):
                miner.recieve(rating)

    # sends a new block to everyone in the network
    def send_block(self,user,block):
        for curr_user in self.users:
            if not(curr_user is user):
                curr_user.recieve_block(block)

#Generic user of website
class User:
    def __init__(self, money = 0, blockchain = None):
        self.money = money
        self.blockchain = blockchain

    #adds block to its current block chain to see if i
    def recieve_block(self,block):
        if User.Valid_Block(block,self.blockchain):
            self.blockchain.add(block)
        else:
            return False
        return True

    # checks to see if valid block to add to blockchain
    @staticmethod
    def Valid_Block(block,blockchain):
        if isinstance(block,Block) and isinstance(blockchain,BlockChain):
            #ensures that the current block has the previous hash
            if block.header == blockchain.get_last_hash() and User.__Valid_Ratings(block.rating_lst):
                return True
        return False

    # checks if the ratings in a block list are correctly defined
    @staticmethod
    def __Valid_Ratings(rating_lst):
        pass

class Miner(User):
    def __init__(self):
        pass
    def mine(self):
        pass
    def add_block_to_blockchain(self):
        pass
    def send_block_to_users(self):
        pass

# users that rank documents
class Ranker(User):
    def __init__(self):
        pass

# incase a user is a ranker and a miner
class Miner_Ranker(User,Miner,Ranker):
    def __init__(self):
        pass

#defining nonusers hard objects
class Document:
    def __init__(self):
        pass

# defines a rating generated by a user for a document
class Rating:
    def __init__(self):
        pass

# A Block that is placed in the block chain
class Block:
    #class variables
    max_num_ratings = 100

    def __init__(self,prefix,footer,rating_lst):
        self.prefix = prefix
        self.rating_lst = []
        self.footer = footer

        for rating in rating_lst:
            if len(rating) < Block.max_num_ratings:
                if isinstance(rating,Rating):
                    self.rating_lst.append(rating)
            else:
                break

    def add_ratings(self,rating_lst):
        for rating in rating_lst:
            if len(rating) < max_num_ratings:
                if isinstance(rating,Rating):
                    self.rating_lst.append(rating)
            else:
                break

    def change_footer(self,footer):
        self.footer = footer

    def change_header(self,header):
        self.header = header

    # replaces the ratings information with the new information
    def replace_ratings(self,rating_lst):
        first = -1
        for i,rating in enumerate(rating_lst):
            if len(self.rating_lst) < max_num_ratings:
                if isinstance(rating,Rating):
                    self.rating_lst.append(rating)
            elif first == -1:
                first = i
            else:
                if i - first >= len(rating_lst) - 1:
                    first = i
                self.rating_lst[i-first] = rating

#Block Chain class type
class BlockChain:
    def __init__(self,block_lst = []):
        if all(map(lambda x: isinstance(x,Block), block_lst)):
            self.block_lst = block_lst
        else:
            self.block_lst = []

    def add_block(self,block):
        if isinstance(block,Block):
            self.block_lst.append(block)

    #gets the hash of the last block in the block_chain
    def get_last_hash(self):
        length = len(self.block_lst)
        if length == 0:
            return None
        else:
            last_block = self.block_lst[length]
            return last_block.footer